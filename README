To do
=====

Syntax

  defining and creating components
    create ... block
/   defaults { ... }  and setup { ... }
    state methods: flow Foo { def ... }
      generalization of alg flows
/ flows, transitions, etc.
    deftly handle multiple actions in a transition, etc.
      (chain the blocks?)
  state S1, S2, ... should set S as init state?
  running
    run N { dt = ...; zeno = ... }
    run_while, run_until
? input, output, connect
  c-shift translator (both ways)

Semantics

/ inheritance
/   explicit, calculated before run, cached
/   implicit, based on ruby inheritance
/   Exit transition
/   trans.name = nil to prevent hiding
  inheritance from mixins
  indeterminate transitions chosen randomly?

  math
    fixed point, rationals
/   complex numbers
    matrices, lapack, etc
  
  metaclasses
  
  discrete evolution
    more flexibility:
      start actions as well as finish actions
      (before/after)
      enter and exit blocks for each state
    transitions like in statechart
    parametric transitions?
    attach :all, ...
    syncronization
      explicit?
    allow event of transition to be a block or proc returning the events
  
Implementation

  use alias instead of def in Event#(un)export
    or use extend_object
  
  abstract hash-inheritance and use it in meta.rb and option-block.rb

  optimization
    profiling
    compare with shift, matlab
    integration method
    flows
    guards
    dual mode
  
/ garbage collection
/   nil out the components array, do GC, reconstruct components array
x   do this periodically if user sets flag

  math
/   runge-kutta 4
/?  mixing runge-kutta 4 with euler
      justify '$RK_level < 2'
    var step
    symbolic integration

  debugging, logging
    use AspectR, alias
  
  run time error checking
    catch infinite loops in alg. flows
    
  exception handling
    syntax errors, esp. in flows, guards
  
  unit tests
    integrator (start with solution involving diff'able fns)
      solve eqn in complex vars with and without Complex class
    inheritance
    transitions and events
  
  system tests
    compare with other integrators (accuracy)
    
/ test windows version
  
/ persistence
  
  distributed processing

User interface

  command-line debugger
    inspect methods
    catch ^C --> redshift should break into debugger, by default
    'run' in a thread
    send event from outside
  
  run command
    should add dt, zeno, time (in sec) in optBlock
    pass block to run before/after each timestep
  
  nedit syntax coloring
    
  gui debugger

/ output to gnuplot

Examples
  http server for simulation, html interface
  matrices
  distributed
  persistence

Documentation

  translate cshift examples (ball, springs, etc.)
  differences from cshift
    simulation semantics
      event semantics like lambda-shift
    programming language semantics
      inheritance
        ruby inheritance of attrs, methods
        transitions, flows, states, events
        advanced topics: include modules for mixins
        overriding inherited trans./flows by name
          using nil to prevent overriding
    no mixing scopes in create, as in "create(Foo, x := x)"
    warning about:
      'self.x = ...'
      associativity of and/or
      C-like operators (i.e., = and == vs. := and =), but no ++, --
      truth values
      names w/ capitals etc.
      fixnums vs. floats
        fix / fix ==> fix
      end of line-- finish with op or comma or \ to continue
    during discrete phase, cached algebraic flows do not change
      they do not have function semantics
      evaluated only once per timestep
        no extra side effects, faster
        leads to small error when used with rk4
    world.clock shouldn't be used during rk
      use a timer based on an EulerFlow
   
   dynamic semantics
     changing a flow preserves inherited/overridden flows in subclasses
   
   restrictions
     singleton methods cannot be exported (see Event)
     singleton methods will be lost in World#save
