To do
=====

Syntax

  defining and creating components
? input, output, connect

Semantics

/  inheritance
/   explicit, calculated before run, cached
/   implicit, based on ruby inheritance
/   Exit transition
/   trans.name = nil to prevent hiding

  math
    fixed point, rationals
/   complex numbers
    matrices, lapack, etc
  
  metaclasses
  
  discrete evolution
    more flexibility:
      start actions as well as finish actions
      (before/after)
    transitions like in statechart
    parametric transitions?
    attach :all, ...

  
Implementation

  optimization
    profiling
    compare with shift, matlab
    integration method
    flows
    guards
    dual mode
  
/  garbage collection
    nil out the components array, do GC, reconstruct components array
    do this periodically if user sets flag

  math
/   runge-kutta 4
/?  mixing runge-kutta 4 with euler
      justify '$RK_level < 2'
    var step
    symbolic integration

  debugging, logging
    use AspectR
  
  run time error checking
  exception handling
    syntax errors, esp. in flows, guards
  
  unit tests
    integrator (start with solution involving diff'able fns)
    inheritance
    transitions and events
  
  system tests
    compare with other integrators (accuracy)
  
  persistence
  
  distributed processing

User interface

  command-line debugger
    inspect methods
  
  run command
    should add dt, zeno, time (in sec) in optBlock
    pass block to run before/after each timestep
    
  gui debugger
  output to gnuplot

Documentation

  translate cshift examples (ball, springs, etc.)
  differences from cshift
    simulation semantics
      event semantics like lambda-shift
    programming language semantics
      inheritance
        ruby inheritance of attrs, methods
        transitions, flows, states, events
        advanced topics: include modules for mixins
        occlusion of inherited trans./flows by name
          using nil to prevent occlusion
    no mixing scopes in create, as in "create(Foo, x := x)"
    warning about:
      'self.x = ...'
      associativity of and/or
    during discrete phase, cached algebraic flows do not change
      they do not have function semantics
      evaluated only once per timestep
      this is consistent with diff flows
      semantics is the same during continuous phase (and faster)
        except for no extra side effects
    world.clock_now shouldn't be used during rk
      use a timer based on an EulerFlow
   
   restrictions
     singleton methods cannot be exported (see Event)
