To do
=====

Syntax

  defining and creating components
  input, output, connect

Semantics

  inheritance
    explicit, calculated before run, cached
    implicit, based on ruby inheritance
    Exit transition

  math
    complex numbers
    matrices, lapack, etc
  
  metaclasses
  
  discrete evolution
    more flexibility:
      start actions as well as finish actions
      (before/after)
    transitions like in statechart
    parametric transitions?

  
Implementation

  optimization
    profiling
    compare with shift, matlab
    integration method
    flows
    guards
    dual mode
  
  garbage collection
    nil out the components array, do GC, reconstruct components array
    do this periodically if user sets flag

  math
    mixing runge-kutta 4 with euler
      justify '$RK_level < 2'
    var step
    symbolic integration

  debugging, logging
    use AspectR
  
  run time error checking
  exception handling
    syntax errors, esp. in flows, guards
  
  unit tests
  
  system tests
    compare with other integrators

User interface

  command-line debugger
    inspect methods
  
  run command
    should add dt, zeno, time (in sec) in optBlock
    
  gui debugger
  output to gnuplot

Documentation

  differences from cshift
    event semantics like lambda-shift
    no mixing scopes in create, as in "create(Foo, x := x)"
    'self.x = ...'
    during discrete phase, cached algebraic flows do not change
      they do not have function semantics
      evaluated only once per timestep
      this is consistent with diff flows
      semantics is the same during continuous phase (and faster)
        except for no extra side effects
   
   restrictions
     singleton methods cannot be exported (see Event)
