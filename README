To do
=====

Syntax

  defining and creating components
x   classes should have a "static setup" clause
x     because of commit, cannot create components statically
x     (THIS IS A PROBLEM)
x     actually, this is consistent with having Worlds:
x       you can't create a Component statically, because you don't
x       have a world yet
    need to prevent calling new on Component class
    create ... block
/   defaults { ... }  and setup { ... }
    state methods: flow Foo { def ... }
      generalization of alg flows
/ flows, transitions, etc.
    deftly handle multiple actions in a transition, etc.
      (chain the blocks?)
  subflows, as in shift (maybe by defining a method on FlowParser?)
? state S1, S2, ... should set S as init state
? input, output, connect -- see tank_monit.rb
  c-shift translator (both ways)
  redshift parser to make flows etc. nicer
    invoke by putting /usr/bin/env redshift in header
    allows nedit syntax mode for redshift
  static data typing
    setters for flows should check for data type
    flows should have a declared data type
  
  should time-step automatically be converted to Float?

Semantics

/ inheritance
/   explicit, calculated before run, cached
/   implicit, based on ruby inheritance
/   Exit transition
/   trans.name = nil to prevent hiding
  inheritance from mixins
? indeterminate transitions chosen randomly

  math
    fixed point, rationals
/   complex numbers
    matrices, lapack, etc
  
  metaclasses
  
  discrete evolution
    more flexibility:
      start actions as well as finish actions
      (before/after)
      enter and exit blocks for each state
      start_when and finish_when to implement sync
    transitions like in statechart
    parametric transitions?
    attach :all, ...
    syncronization
      explicit?
    events that persist until sender changes state (or end of discrete step?)
?   allow event of transition to be a block or proc returning the events

Metasimualtion layer
  methods to tell an object to change state, etc.
  method to send message to object(s)

Implementation

  use eval %{ ... } instead of eval <<END ... END
  
  for flow/transition inheritance, use instance vars of singleton classes:
    def A.set_flows f; @flows = f; end
    and x.class.get_flows

  use alias instead of def in Event#(un)export
    or use extend_object
  
  abstract hash-inheritance and use it in meta.rb and option-block.rb

  optimization
    profiling
    compare with shift, matlab
    integration method
    flows
      algebraic flows should override update (to do nothing)
        instead of having a setter do nothing. Then the setter
        should raise an exception.
    guards
      clause to set how often the guard is checked
    dual mode
  
/ garbage collection
/   nil out the components array, do GC, reconstruct components array
x   do this periodically if user sets flag

  math
/   runge-kutta 4
/?  mixing runge-kutta 4 with euler
      justify '$RK_level < 2'
    var step
    symbolic integration
    other integrators:
      average x' at endpoints to get approx. delta_x
    automatically scan formulas and use best alg.

  debugging, logging
    use AspectR, alias
  
  run time error checking
    catch infinite loops in alg. flows
    zeno
      limit can scale w/ num components
    
  exception handling
    syntax errors, esp. in flows, guards
  
  unit tests
    integrator (start with solution involving diff'able fns)
      solve eqn in complex vars with and without Complex class
/   inheritance
    transitions and events
    dynamism:
      changing flows and transitions on classes which have instances
  
  system tests
    compare with other integrators (accuracy)
    
/ test windows version
  
/ persistence
  
  distributed processing

User interface

  command-line debugger, interactive redshift (irs)
    inspect methods
    catch ^C --> redshift should break into debugger, by default
    'run' in a thread, or in sub-irb shell (with self = world)
    send event from outside
  
  run command
    should add dt, zeno, steps, time (in sec) in optBlock
      run N { dt = ...; zeno = ... }
/   pass block to run before/after each timestep
    run_while, run_until
      steps N, time T, continuous, discrete
      run { while {...} }
    next_transition
  
  nedit syntax coloring
    
  gui debugger

/ output to gnuplot
    use pipe for simple animation?

Examples
  http server for simulation, html interface
  matrices
  distributed
/ persistence

Documentation

  translate cshift examples (ball, springs, etc.)
  differences from cshift
    simulation semantics
      event semantics like lambda-shift
      no static creation of components
        must create world first
        philosophy:
          Component *definitions* precede World *specification*
    programming language semantics
      input/output/connect not needed because vars are untyped
      inheritance
        ruby inheritance of attrs, methods
        transitions, flows, states, events
        advanced topics: include modules for mixins
        overriding inherited trans./flows by name
          using nil to prevent overriding
    no mixing scopes in create, as in "create(Foo, x := x)"
    warning about:
      'self.x = ...'
      associativity of and/or
      C-like operators (i.e., = and == vs. := and =)
        but no ++, --, only +=, -=, etc.
      truth values
      names w/ capitals etc.
      fixnums vs. floats
        fix / fix ==> fix
        (maybe setters should check for this?)
      end of line-- finish with op or comma or \ to continue
      fwd refs
      no error checking with "@x = ..." if x doesn't already exist
    during discrete phase, cached algebraic flows do not change
      they do not have function semantics
      evaluated only once per timestep
        no extra side effects, faster
        leads to small error when used with rk4
    world.clock shouldn't be used during rk
      use a timer based on an EulerFlow
   
   dynamic semantics
     changing a flow preserves inherited/overridden flows in subclasses
   
   restrictions
     singleton methods cannot be exported (see Event)
     singleton methods will be lost in World#save

  performance notes
    don't call run repeatedly, call run n with a block
      otherwise discrete step happens 2x each time
    avoid complex non-numerical constructs in flows
      can usually be done in discrete step anyway
