To do
=====

Syntax

  defining and creating components
    create ... block
/   defaults { ... }  and setup { ... }
    state methods: flow Foo { def ... }
      generalization of alg flows
/ flows, transitions, etc.
    deftly handle multiple actions in a transition, etc.
      (chain the blocks?)
? state S1, S2, ... should set S as init state
? input, output, connect -- see tank_monit.rb
  c-shift translator (both ways)
  redshift parser to make flows etc. nicer
    invoke by putting /usr/bin/env redshift in header
    allows nedit syntax mode for redshift

Semantics

/ inheritance
/   explicit, calculated before run, cached
/   implicit, based on ruby inheritance
/   Exit transition
/   trans.name = nil to prevent hiding
  inheritance from mixins
? indeterminate transitions chosen randomly

  math
    fixed point, rationals
/   complex numbers
    matrices, lapack, etc
  
  metaclasses
  
  discrete evolution
    more flexibility:
      start actions as well as finish actions
      (before/after)
      enter and exit blocks for each state
      start_when and finish_when to implement sync
    transitions like in statechart
    parametric transitions?
    attach :all, ...
    syncronization
      explicit?
?   allow event of transition to be a block or proc returning the events
  
Implementation

  use eval %{ ... } instead of eval <<END ... END

  use alias instead of def in Event#(un)export
    or use extend_object
  
  abstract hash-inheritance and use it in meta.rb and option-block.rb

  optimization
    profiling
    compare with shift, matlab
    integration method
    flows
    guards
    dual mode
  
/ garbage collection
/   nil out the components array, do GC, reconstruct components array
x   do this periodically if user sets flag

  math
/   runge-kutta 4
/?  mixing runge-kutta 4 with euler
      justify '$RK_level < 2'
    var step
    symbolic integration

  debugging, logging
    use AspectR, alias
  
  run time error checking
    catch infinite loops in alg. flows
    
  exception handling
    syntax errors, esp. in flows, guards
  
  unit tests
    integrator (start with solution involving diff'able fns)
      solve eqn in complex vars with and without Complex class
/   inheritance
    transitions and events
  
  system tests
    compare with other integrators (accuracy)
    
/ test windows version
  
/ persistence
  
  distributed processing

User interface

  command-line debugger, interactive redshift (irs)
    inspect methods
    catch ^C --> redshift should break into debugger, by default
    'run' in a thread, or in sub-irb shell (with self = world)
    send event from outside
  
  run command
    should add dt, zeno, steps, time (in sec) in optBlock
      run N { dt = ...; zeno = ... }
    pass block to run before/after each timestep
    run_while, run_until
      steps N, time T, continuous, discrete
      run { while {...} }
    next_transition
  
  nedit syntax coloring
    
  gui debugger

/ output to gnuplot
    use pipe for simple animation?

Examples
  http server for simulation, html interface
  matrices
  distributed
/ persistence

Documentation

  translate cshift examples (ball, springs, etc.)
  differences from cshift
    simulation semantics
      event semantics like lambda-shift
    programming language semantics
      input/output/connect not needed because vars are untyped
      inheritance
        ruby inheritance of attrs, methods
        transitions, flows, states, events
        advanced topics: include modules for mixins
        overriding inherited trans./flows by name
          using nil to prevent overriding
    no mixing scopes in create, as in "create(Foo, x := x)"
    warning about:
      'self.x = ...'
      associativity of and/or
      C-like operators (i.e., = and == vs. := and =), but no ++, --
      truth values
      names w/ capitals etc.
      fixnums vs. floats
        fix / fix ==> fix
      end of line-- finish with op or comma or \ to continue
      fwd refs
      no error checking with "@x = ..." if x doesn't already exist
    during discrete phase, cached algebraic flows do not change
      they do not have function semantics
      evaluated only once per timestep
        no extra side effects, faster
        leads to small error when used with rk4
    world.clock shouldn't be used during rk
      use a timer based on an EulerFlow
   
   dynamic semantics
     changing a flow preserves inherited/overridden flows in subclasses
   
   restrictions
     singleton methods cannot be exported (see Event)
     singleton methods will be lost in World#save

  performance notes
    don't call run repeatedly, call run n with a block
      otherwise discrete step happens 2x each time
