To do
=====

Syntax

  express flows, guards, etc, in ruby syntax and use something to parse:
  
    nodedump/nodewrap
    
    ripper
    
    "expansion.rb"

  resets and even assignment to cont-vars can use '<=' or '[]='

  check for symbol conflicts
    user attributes may conflict with Component's attrs
    ditto for flows and other methods defined in subclasses
    can we 'hook' method def and attr def to check for conflict? 
    or just use a consistent naming scheme to keep internals separate?

  reset clauses:
    transition A => B do
      reset " x := expr ", ...
    setup and defaults, too
    this might get around the self.x danger for casual users
    OR: don't use 'foo = ...' in resets, use 'foo ...' instead
      but thid has the danger of being used in the wrong way in other contexts
    OR: use string syntax and eval the block against a binding which ...
      but inefficient

? 'when' as alias for 'guard'
x if "flow :state" or "transition :state => :other-state"
    lookup or generate a state with that name
  defining and creating components
x   classes should have a "static setup" clause
x     because of commit, cannot create components statically
x     (THIS IS A PROBLEM)
x     actually, this is consistent with having Worlds:
x       you can't create a Component statically, because you don't
x       have a world yet
  world subclasses and individual worlds should have chainable static
    setup clauses
    
/   need to prevent calling new on Component class
    create ... block
      shouldn't use instance_eval but instead run in the caller's context?
      better: use hash of 'var => value, ...'
/   defaults { ... }  and setup { ... }
    state methods: flow Foo { def ... }
      generalization of alg flows
/ flows, transitions, etc.
    deftly handle multiple actions in a transition, etc.
      (chain the blocks?)
  subflows, as in shift (maybe by defining a method on FlowParser?)
? state S1, S2, ... should set S as init state
? input, output, connect -- see tank_monit.rb
  c-shift translator (both ways)
  redshift parser to make flows etc. nicer
    invoke by putting /usr/bin/env redshift in header
    allows nedit syntax mode for redshift
    syntax checking for 'action { x = 3 }', newlines which change meaning, etc.
  static data typing
    setters for flows should check for data type
    flows should have a declared data type
  don't allow lower case state names
x should time-step automatically be converted to Float?

Semantics

  add reset clause to transitions (in effect, like L-S)
    transition ...
      reset :x => { <expression> }
      reset "my_array[10,20]" => { <expression> }
      
    Not lovely, but clear enough. The array string will get eval-ed
    (once!) into a lambda which assigns to the position in the array.
    
    reset "x=y","z=w"
      OR: action "x=y","z=w" do ... end
        where the block is treated as actions were before
        I'm not sure I like this...
    evaluated in parallel for all components which are taking transitions at
      a particular discrete time
    guard guaranteed to be true during eval of RHS, if no side effects
    precedes action
      actions are still evaluated in sequence and allow arb. code
      no guarantees--up to programmer to control concurrency
  
  semaphores on variables to control concurrency in action clauses
    but there's no way to wait for resource to become free
    need a multiplexed global which says "which component is active"
      actually, world.rb has this
    accessors can check this global
    but who has write priority?
      how is contention handled deterministically?
      does it generate an exception when two components ask for the same
        write lock at the same time? Or is it a program error?
    need exception handlers
    
  exception handler clauses in transitions (or use interrupts?)
    on LockFailed { |var, value| ... }
  
  state stack:
    a transition (or interrupt) can push the current state or pop back
      to a previously saved state (like Kader's idea)
    syntax:
      transition ... do
        push [or pop, in which case the dest. state is ignored]
      end
  
  interrupts
    a way of enabling a transition without evaluating guards
      -faster
    can do sender-receiver, rather than broadcast
    can register with global interrupt manager
      notify after T seconds
      notify when global event happens (like what?)
    receive in any state, switch to new state optional (push ok)
    synchronous in the sense that no other components act in between
      the send and receive, and the receiver action happens before the
      sender action finishes (?)
    but not parallel assignment
    based on methods
    in sender's action clause: 'x.foo args'
    in receiver:
      interrupt :foo => NewState do
        action { |args| ...}
        event ...
      end
  
  signals
    maybe better than interrupts, more general
    
    transition ... do
      signal value => receiver_collection, ...
    end
    
    on value do ... end
    
    is this better than a simple method call?
      yes: can implement queue

/ inheritance
/   explicit, calculated before run, cached
/   implicit, based on ruby inheritance
/   Exit transition
/   trans.name = nil to prevent hiding
  inheritance from mixins

  Possible to arrange discrete stuff so other semantics is pluggable?
  
? indeterminate transitions chosen randomly, as an option
    randomize order of component list, and order of transition lists?

  in create(Comp) { ... }, should arrive at Enter before evaling block?
    otherwise flow methods don't work in block

  math
    fixed point, rational integration?
/   complex numbers
    matrices, lapack, etc
    maybe override integer division to output float?
      use 'require "mathn"; include Math", like irb -m.
  
  metaclasses
  
  discrete evolution
    more flexibility:
      start actions as well as finish actions
      (before/after)
      enter and exit blocks for each state
      start_when and finish_when to implement sync
    transitions like in statechart
    parametric transitions?
    attach :all, ...
    syncronization
      explicit?
    events that persist until sender changes state (or end of discrete step?)
?   allow event of transition to be a block or proc returning the events

  exceptions
    catch them if they arise in action
    pass them on to handler where?

Metasimualtion layer
  methods to tell an object to change state, etc.
  method to send message to object(s)

Implementation

  is it possible to give a hint/declaration to the effect that a guard
    refers only to continuous values, so only needs to be checked once
    per time-step?

  use eval %{ ... } instead of eval <<END ... END
  
* for flow/transition inheritance, use instance vars of singleton classes:
    def A.set_flows f; @flows = f; end
    and x.class.get_flows
    don't use class vars in meta.rb

  use alias instead of def in Event#(un)export
    or use extend_object
  
  abstract hash-inheritance and use it in meta.rb and option-block.rb

  optimization
    profiling
      use valgrind, gprof, etc. to profile the C code
    compare with shift, matlab
    integration method
    flows
      algebraic flows should override update (to do nothing)
        instead of having a setter do nothing. Then the setter
        should raise an exception.
    guards
      clause to set how often the guard is checked
    dual mode
  
/ garbage collection
/   nil out the components array, do GC, reconstruct components array
x   do this periodically if user sets flag

  math
/   runge-kutta 4
/?  mixing runge-kutta 4 with euler
      justify '$RK_level < 2'
    var step
    symbolic integration
    other integrators:
      average x' at endpoints to get approx. delta_x
x   automatically scan formulas and use best alg.

  debugging, logging
    use AspectR, alias
  
  run time error checking
    more 'if $DEBUG ...' checks
/     use $DEBUG when testing.
    catch infinite loops in alg. flows
    zeno
      limit can scale w/ num components
    catch definition of flows after commit, etc.
    error reporting: use Minero Aoki's must.rb to check types etc.
    
  exception handling
    syntax and math errors, esp. in flows, guards
    use Exception classes
  
  unit tests
    integrator (start with solution involving diff'able fns)
      solve eqn in complex vars with and without Complex class
/   inheritance
    transitions and events
    dynamism:
      changing flows and transitions on classes which have instances
  
  system tests
    compare with other integrators (accuracy)
    
/ test windows version
  
  World#copy (use marshal, and the tricks in save/open)
  World#== (recursively compare component list)
  Component#== ?
  
/ persistence
    persist_name of nested state shouldn't be :C::S1 ?
    make CShadow data persist by temporarily caching in in a hash
  
  distributed processing

User interface

  command-line debugger, interactive redshift (irs)
    inspect methods
    catch ^C --> redshift should break into debugger, by default
    'run' in a thread, or in sub-irb shell (with self = world)
    send event from outside
  
  run command
    should add dt, zeno, steps, time (in sec) in optBlock
      run N { dt = ...; zeno = ... }
/   pass block to run before/after each timestep
    run_while, run_until
      steps N, time T, continuous, discrete
      run { while {...} }
    next_transition
  
  nedit syntax coloring
    
  gui debugger

/ output to gnuplot
    use pipe for simple animation?

Examples
  http server for simulation, html interface
  matrices
  distributed
/ persistence

Documentation

  restrictions
    singleton methods cannot be exported (see Event)
    singleton methods will be lost in World#save
    can't use modules to define flows, transitions, etc.

  performance notes
    don't call run repeatedly, call run n with a block
      otherwise discrete step happens 2x each time
    avoid complex non-numerical constructs in flows
      can usually be done in discrete step anyway
