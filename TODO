To do
=====

Syntax

  replace strictly_* with strict_* and alias back for compat

  express flows, guards, etc, in ruby syntax and use something to parse:
  
    nodedump/nodewrap
    
    ripper
    
    "expansion.rb"

    vars are class methods returning Var obejcts

      resets and even assignment to cont-vars can use '<<'

      equations can use '=='

  check for symbol conflicts
    user attributes may conflict with Component's attrs
    ditto for flows and other methods defined in subclasses
    can we 'hook' method def and attr def to check for conflict? 
    or just use a consistent naming scheme to keep internals separate?

  transition do ... end with no states should apply to all S=>S not just to
   Enter=>Enter ?

Semantics

  inheritance among states:
  
    "state Foo has everything that Bar has, plus ...."

  how to set a local var during a transition (which can be accessed by
  events, actions, resets):
    
    set :local => proc {long complex calculation}
    event :e => proc {local}
    reset :v => proc {local}

  a transition that can happen only once per discrete step, to easily
  prevent zeno pb (useful for utility transitions, such as output)

  need a strict_link (NOT constant_link) type so that strictly_continuous is
  preserved when equation involves a link that doesn't change.
  
  allow outside code to tell component to change state? send event to comp?

  "finalizers" for components -- called when component exits, world
   is finalized, or app quits
  
  abstract classes
  
  resets for links
  
  input events (in place of interrupts?)
  
    as opposed to normal events, which are output (pull vs. push)
    
    but does this mean arriving events are queued?
    
    this would be useful for timers so that client component doesn't
    have to manage a ref to the timer
  
  "together {}" clause in transitions
  
    or some other way of making resets and events parallel
  
    together do
      before [do..end | "c_func()"]
      reset ...
      event ...
      after [do..end | "c_func()"]
    end
  
  abort guards
  
  wait/sleep
    
    in a transition, saying "sleep n" says that the component will not
    check guards for the rest of that discrete update and for n time units.
    
  exception handler clauses in transitions (or use interrupts?)
    on LockFailed { |var, value| ... }
  
  state stack:
    a transition (or interrupt) can push the current state or pop back
      to a previously saved state (like Kader's idea)
    syntax:
      transition ... do
        push [or pop, in which case the dest. state is ignored]
      end
  
  interrupts
    a way of enabling a transition without evaluating guards
      -faster
    can do sender-receiver, rather than broadcast
    can register with global interrupt manager
      notify after T seconds
      notify when global event happens (like what?)
    receive in any state, switch to new state optional (push ok)
    synchronous in the sense that no other components act in between
      the send and receive, and the receiver action happens before the
      sender action finishes (?)
    but not parallel assignment
    based on methods
    in sender's action clause: 'x.foo args'
    in receiver:
      interrupt :foo => NewState do
        action { |args| ...}
        event ...
      end
  
  signals
    maybe better than interrupts, more general
    
    transition ... do
      signal value => receiver_collection, ...
    end
    
    on value do ... end
    
    is this better than a simple method call?
      yes: can implement queue

  randomize order of component list, and order of transition lists, optionally

  discrete evolution
    more flexibility:
      start actions as well as finish actions
      (before/after)
      enter and exit blocks for each state
      start_when and finish_when to implement sync
    transitions like in statechart
    parametric transitions?
    attach :all, ...
    syncronization
      explicit?

  exceptions
    catch them if they arise in action
    pass them on to handler where?

Implementation

  Add a #connect method:
  
    link :comp => [C, :x, :y, :z]
    ...
    action do
      self.comp = C.new
      connect :comp, :x => :x_in_c, ...
    end
    
  or:
    
    link :comp => Connector(:x)
    action/setup do
      other = create(SomeComp)
      connect [:comp, :x] => [other, :y]
    end
    flow do
      "  u'  =  comp.x  "
    end
    
    creates a new connector component so that neither self nor SomeComp
    nor other need to know statically the offset of the other guy's var
    
    (do we need to specify :x ??)

  constants and links should be resettable (see test_constant)

  share mark and free funcs where possible (e.g., guards)
  
  guards should not be written in numerical order (".._0", "..._1"), but
  in a more meaningful way so that changing order doesn't force recompile
  
  unified internal rep. or phases
  
  insert a mnemonic for quick detection of phase type in discrete update

  distribute Init_clib better
  
  optimization
    profiling
      use valgrind, gprof, etc. to profile the C code
    compare with shift, matlab
  
  run time error checking
    more 'if $DEBUG ...' checks
    catch definition of flows after commit, etc.
    
  exception handling
    syntax and math errors, esp. in flows, guards
    use Exception classes

  error messages

    Current file/line position must be saved by many constructs, e.g. reset,
      so that it can be shown later if there is an error message

  check against ruby 1.9
  
    replace RARRAY(x)->len with RARRAY_LEN(x)

  libtcc backend
  
  dot backend (see file in lib dir)
  
User interface

  yaml and pp outputs

Tools

  profiler mixin for World (also an executable script?)

  debugger mixin for World (also an executable script?)
    
  generalize the irb-shell.rb and TO4230 shells, and make RedShift::Shell
  
    use this in ZenoDebugger, too
    
    can this be a mixin for World
