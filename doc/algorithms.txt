run n:

  if not started
    do_setup
    started = true
  
  step_discrete
  
  for n steps
    step_continuous
    step_discrete


step_continuous:

  for rk_level from 0 to 4
    for each component
      for each continuous var
        if rk_level == 0
          set var->rk_level = 0
          if no flow for var, copy var->value_0 to var->value_{1,2,3}
        else
          if non-algebraic flow and var not updated for rk_level
            evaluate the flow at rk_level
          if rk_level == 4
            clear d_tick for var
            
  set global d_tick = 1 so that alg flows will be recalculated
  set rk_level = 0


step_discrete:

0 clear active_comp, prev_active_comp arrays:
    set length = 0
    make sure actual size is at least that of comp array

1 each comp:
    check guards of transitions from the current state
    if guard of (trans, dest) is true
      put (comp, trans, dest) in active_comp array
  
2 each prev_active_comp:
    unexport its events

3 if no active_comps, done
3'if no active_comps AND no prev_active_comps, done
  (in case unexporting some event enables some transition)

4 each active_comp:
    export events

5 each active_comp:
    do actions of t until reset found (actions should not change cont vars)
  
6 each active_comp:
    each var:
      if t has reset for var (before next set of actions)
        compute reset
        store in value_1 of var
      else
        copy from value_0 to value_1

7 incr d_tick if there was a reset (to invalidate cached alg flows)
    
8 each active_comp:
    each var:
      copy from value_1 to value_0

9 repeat 5-8 until no more actions or resets

10 move active_comp array to prev_active_comp

11 repeat 1-10
